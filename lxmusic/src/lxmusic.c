/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <stdlib.h>
#include <string.h>
#include <xmmsclient/xmmsclient.h>
#include <xmmsclient/xmmsclient-glib.h>

enum {
    COL_ID = 0,
    COL_ARTIST,
    COL_ALBUM,
    COL_TITLE,
    COL_LEN,
    N_COLS
};

enum {
    REPEAT_NONE,
    REPEAT_CURRENT,
    REPEAT_ALL
};

enum {
    FILTER_ALL,
    FILTER_TITLE,
    FILTER_ARTIST,
    FILTER_ALBUM
};

typedef struct _UpdateTrack{
    const char* playlist;
    GtkListStore* list;
    GtkTreeIter it;
}UpdateTrack;

typedef struct _FilterCriteria{
    char* keyword;
    int cols;
}FilterCriteria;

typedef struct _PageData{
    char* playlist;
    FilterCriteria* criteria;
}PageData;

static xmmsc_connection_t *con = NULL;
static GtkWidget *main_win = NULL;
static GtkWidget *play_btn = NULL;
static GtkWidget *time_label = NULL;
static GtkWidget *progress_bar = NULL;
static GtkWidget *status_bar = NULL;
static GtkWidget *notebook = NULL;
static GtkWidget *volume_btn = NULL;

static guint playback_status = 0;
static guint play_time = 0;
static guint current_track_len = 0;
static guint current_id = 0;

static int repeat_mode = REPEAT_ALL;
static int filter_field = FILTER_ALL;

static const char* get_cur_playlist_name()
{
    int i = gtk_notebook_get_current_page(notebook);
    GtkWidget* scroll = gtk_notebook_get_nth_page(notebook, i);
    GtkWidget* view = gtk_bin_get_child(scroll);
    return (const char*)g_object_get_data( view, "pl_name" );
}

static GtkWidget* get_cur_playlist_view()
{
    int i = gtk_notebook_get_current_page(notebook);
    GtkWidget* scroll = gtk_notebook_get_nth_page(notebook, i);
    GtkWidget* view = gtk_bin_get_child(scroll);
    return view;
}

static GtkWidget* get_playlist_view( const char* pl_name )
{
    int i, n;
    n = gtk_notebook_get_n_pages(notebook);
    for(i =0; i< n; ++i)
    {
        GtkWidget* scroll = gtk_notebook_get_nth_page(notebook, i);
        GtkWidget* view = gtk_bin_get_child(scroll);
        char* name = (char*)g_object_get_data(view, "pl_name");
        if( name && strcmp( pl_name, name) == 0 )
            return view;
    }
    return NULL;
}

static GtkWidget* get_playlist_store( const char* name )
{
    GtkWidget* view = get_playlist_view(name);
    if( view )
    {
        GtkTreeModel* filter = gtk_tree_view_get_model(view);
        if( filter )
            return gtk_tree_model_filter_get_model((GtkTreeModelFilter*)filter);
    }
    return NULL;
}

static void filter_criteria_free( FilterCriteria* f )
{
    g_free(f->keyword);
    g_slice_free(FilterCriteria, f);
}

void on_main_win_destroy(GtkWidget* win)
{
    gtk_main_quit();
}

void on_about(GtkWidget* mi, gpointer data)
{
    const char* authors[] = { "洪任諭 (Hong Jen Yee) <pcman.tw@gmail.com>", NULL };
    GtkWidget* about = gtk_about_dialog_new();
    gtk_about_dialog_set_name( (GtkAboutDialog*)about, "LXMusic" );
    gtk_about_dialog_set_logo_icon_name(about, "lxmusic");
    gtk_about_dialog_set_version( (GtkAboutDialog*)about, VERSION );
    gtk_about_dialog_set_authors( (GtkAboutDialog*)about, authors );
    gtk_about_dialog_set_comments( (GtkAboutDialog*)about, _("Music Player for LXDE\nSimple GUI XMMS2 client") );
    gtk_about_dialog_set_license( (GtkAboutDialog*)about, "GNU General Public License" );
    gtk_about_dialog_set_website( (GtkAboutDialog*)about, "http://lxde.org/" );
    gtk_window_set_transient_for( (GtkWindow*)about, (GtkWindow*)main_win );
    gtk_dialog_run( (GtkDialog*)about );
    gtk_widget_destroy( about );
}

void on_playlist_row_activated(GtkTreeView* view,
                              GtkTreePath* path,
                              GtkTreeViewColumn* col,
                              gpointer user_data)
{
    xmmsc_result_t* res;
    GtkTreeModelFilter* filter = (GtkTreeModelFilter*)gtk_tree_view_get_model(view);
    /* convert from model filter path to path of underlying liststore */
    path = gtk_tree_model_filter_convert_path_to_child_path(filter, path);
    if( path )
    {
        guint pos = gtk_tree_path_get_indices(path)[0];
        /* FIXME: need to swtich to another playlist sometimes. */
        res = xmmsc_playlist_set_next( con, pos );
        xmmsc_result_unref(res);

        res = xmmsc_playback_tickle(con);
        xmmsc_result_unref(res);

        /* FIXME: just call play is not enough? */
        if( playback_status != XMMS_PLAYBACK_STATUS_PLAY )
            on_play_btn_clicked(play_btn, NULL);
        gtk_tree_path_free(path);
    }
}

void on_filter_field_changed(GtkComboBox* cb, gpointer user_data)
{

}

static gboolean playlist_filter_func(GtkTreeModel* model, GtkTreeIter* it, FilterCriteria* criteria)
{
    char *artist, *album, *title;
    gboolean ret = FALSE;

    if( ! criteria->keyword )
        return TRUE;

    gtk_tree_model_get(model, it,
                       COL_ARTIST, &artist,
                       COL_ALBUM, &album,
                       COL_TITLE, &title, -1);

    if( artist && strstr( artist, criteria->keyword ) )
        ret = TRUE;
    else if( album && strstr( album, criteria->keyword ) )
        ret = TRUE;
    else if( title && strstr( title, criteria->keyword ) )
        ret = TRUE;

    g_free(artist);
    g_free(album);
    g_free(title);

    return ret;
}

void on_filter_entry_changed(GtkEntry* entry, gpointer user_data)
{
    GtkWidget* view = get_cur_playlist_view();
    GtkTreeModelFilter* filter = (GtkTreeModelFilter*)gtk_tree_view_get_model(view);
    FilterCriteria* criteria = (FilterCriteria*)g_object_get_data(filter, "criteria");
    g_free(criteria->keyword);
    criteria->keyword = g_strdup(gtk_entry_get_text(entry));
    gtk_tree_model_filter_refilter(filter);

    /* FIXME: keep selections and keep the selected items visible in current view. */
}

static gboolean file_filter_fnuc(const GtkFileFilterInfo *inf, gpointer user_data)
{
    return g_str_has_prefix(inf->mime_type, "audio/");
}

static gpointer add_file( const char* file )
{
    gboolean is_dir = g_file_test( file, G_FILE_TEST_IS_DIR );
    xmmsc_result_t *res;
    const char* pl = get_cur_playlist_name();
    char *url;

    if( ! pl )
        return;

    /* Since xmms2 uses its own url format, this is annoying but inevitable. */
    url = g_strconcat( "file://", file, NULL );

    if( is_dir )
        res = xmmsc_playlist_radd( con, pl, url );
    else
        res = xmmsc_playlist_add_url( con, pl, url );
    g_free( url );

    if( res )
        xmmsc_result_unref( res );
    return NULL;
}

static void on_add_files( GtkMenuItem* item, gpointer user_data )
{
    enum { RESPONSE_ADD = 1 };
    GtkWidget *dlg = gtk_file_chooser_dialog_new( NULL, (GtkWindow*)main_win,
                                                  GTK_FILE_CHOOSER_ACTION_OPEN,
                                                  GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                  GTK_STOCK_ADD, RESPONSE_ADD, NULL );
    GtkFileFilter* filter;

    gtk_file_chooser_set_select_multiple( (GtkFileChooser*)dlg, TRUE );

    /* add a custom filter which filters autio files */
    filter = gtk_file_filter_new();
    gtk_file_filter_set_name(filter, _("Audio Files"));
    gtk_file_filter_add_custom( filter, GTK_FILE_FILTER_MIME_TYPE, file_filter_fnuc, NULL, NULL );
    gtk_file_chooser_add_filter(dlg, filter);

    filter = gtk_file_filter_new();
    gtk_file_filter_set_name(filter, _("All Files"));
    gtk_file_filter_add_custom( filter, 0, gtk_true, NULL, NULL );
    gtk_file_chooser_add_filter(dlg, filter);

    if( gtk_dialog_run( (GtkDialog*)dlg ) == RESPONSE_ADD )
    {
        GSList* uris = gtk_file_chooser_get_uris( (GtkFileChooser*)dlg );
        GSList* uri;

        if( ! uris )
            return;

        for( uri = uris; uri; uri = uri->next )
        {
            gchar* file = g_filename_from_uri( uri->data, NULL, NULL );
            add_file( file );
            g_free( file );
            g_free( uri->data );
        }
        g_slist_free( uris );
    }
    gtk_widget_destroy( dlg );
}

static void on_add_url( GtkMenuItem* item, gpointer user_data )
{
    GtkWidget *dlg = gtk_dialog_new_with_buttons(
            _("Input a URL"), (GtkWindow*)main_win, GTK_DIALOG_MODAL,
            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
            GTK_STOCK_OK, GTK_RESPONSE_OK, NULL );
    GtkWidget *entry = gtk_entry_new();
    gtk_box_pack_start( (GtkBox*)((GtkDialog*)dlg)->vbox, entry, FALSE, FALSE, 4 );
    gtk_dialog_set_default_response( (GtkDialog*)dlg, GTK_RESPONSE_OK );
    gtk_entry_set_activates_default( (GtkEntry*)entry, TRUE );
    gtk_widget_show_all( dlg );
    if( gtk_dialog_run( (GtkDialog*)dlg ) == GTK_RESPONSE_OK )
    {
        xmmsc_result_t *res;
        const char* url = gtk_entry_get_text( (GtkEntry*)entry );
        res = xmmsc_playlist_add_url( con, "_active", url );
        xmmsc_result_unref( res );
    }
    gtk_widget_destroy( dlg );
}

static void on_add_from_mlib( GtkMenuItem* item, gpointer user_data )
{
    /* FIXME: This might be implemented in the future */
}

void on_add_btn_clicked(GtkButton* btn, gpointer user_data)
{
    GtkWidget* pop = (GtkWidget*)g_object_get_data(btn, "popup");
    GtkWidget* mi;

    if( ! pop )
    {
        pop = gtk_menu_new();
        mi = gtk_menu_item_new_with_mnemonic(_("Add _Files or Folders To Playlist"));
        g_signal_connect(mi, "activate", G_CALLBACK(on_add_files), NULL);
        gtk_menu_shell_append(pop, mi);

        mi = gtk_menu_item_new_with_mnemonic(_("Add _URL To Playlist"));
        g_signal_connect(mi, "activate", G_CALLBACK(on_add_url), NULL);
        gtk_menu_shell_append(pop, mi);
/*
        mi = gtk_menu_item_new_with_mnemonic(_("Add Music from _MediaLib"));
        g_signal_connect(mi, "activate", G_CALLBACK(on_add_from_mlib), NULL);
        gtk_menu_shell_append(pop, mi);
*/
        gtk_widget_show_all(pop);
        g_object_set_data_full(btn, "popup", pop, gtk_widget_destroy);
    }
    gtk_menu_popup(pop, NULL, NULL, NULL, NULL, 1, GDK_CURRENT_TIME );
}

static int intcmp( gconstpointer a, gconstpointer b )
{
    return (int)b - (int)a;
}

void on_remove_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res;
    const char* pl = get_cur_playlist_name();
    if( pl )
    {
        GtkTreeSelection* tree_sel;
        tree_sel = gtk_tree_view_get_selection( (GtkTreeView*)get_cur_playlist_view() );
        GList *sels = gtk_tree_selection_get_selected_rows( tree_sel, NULL );
        GList *sel;
        if( ! sels )
            return;

        for( sel = sels; sel; sel = sel->next )
        {
            GtkTreePath* path = (GtkTreePath*)sel->data;
            sel->data = (gpointer)gtk_tree_path_get_indices( path )[0];
            gtk_tree_path_free( path );
        }

        /*
            sort the list, and put rows with bigger indicies before those with smaller indicies.
            In this way, all indicies won't be changed during removing items.
        */
        sels = g_list_sort( sels, intcmp );

        for( sel = sels; sel; sel = sel->next )
        {
            xmmsc_result_t* res;
            int pos = (int)sel->data;
            res = xmmsc_playlist_remove_entry( con, pl, pos );
            xmmsc_result_unref( res );
        }
        g_list_free( sels );
    }
}

void on_repeat_mode_changed(GtkComboBox* cb, gpointer user_data)
{

}

void on_progress_bar_changed(GtkScale* bar, gpointer user_data)
{
    xmmsc_result_t* res;
    gdouble p = gtk_range_get_value(bar);
    guint new_play_time = p * current_track_len / 100;
    res = xmmsc_playback_seek_ms( con, new_play_time );
    xmmsc_result_unref(res);
}

void on_prev_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playlist_set_next_rel(con, -1);
    xmmsc_result_unref(res);
    res = xmmsc_playback_tickle(con);
    xmmsc_result_unref(res);
}

void on_next_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playlist_set_next_rel(con, 1);
    xmmsc_result_unref(res);
    res = xmmsc_playback_tickle(con);
    xmmsc_result_unref(res);
}

void on_play_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t *res;
    if( playback_status == XMMS_PLAYBACK_STATUS_PLAY )
    {
        res = xmmsc_playback_pause(con);
        xmmsc_result_unref(res);
    }
    else
    {
        res = xmmsc_playback_start(con);
        xmmsc_result_unref(res);
    }
}

void on_stop_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playback_stop(con);
    xmmsc_result_unref(res);
}


static void render_num( GtkTreeViewColumn* col, GtkCellRenderer* render,
                        GtkTreeModel* model, GtkTreeIter* it, gpointer data )
{
    GtkTreePath* path = gtk_tree_model_get_path( model, it );
    char buf[16];
    if( G_UNLIKELY( ! path ) )
        return;
    g_sprintf( buf, "%d", gtk_tree_path_get_indices( path )[0] + 1 );
    gtk_tree_path_free( path );
    g_object_set( render, "text", buf, NULL );
}

static const char* timeval_to_str( guint timeval, char* buf, guint buf_len )
{
    guint hr, min, sec;

    hr = timeval / 3600;
    min = timeval % 3600;
    sec = min % 60;
    min /= 60;
    if( hr > 0 )
        g_snprintf( buf, buf_len, "%.2u:%.2u:%.2u", hr, min, sec );
    else
        g_snprintf( buf, buf_len, "%.2u:%.2u", min, sec );

    return buf;
}

static void update_track( xmmsc_result_t *res, UpdateTrack* ut )
{
    char *artist, *album, *title;
    guint time_len = 0;
    char time_buf[32];

    if( xmmsc_result_iserror( res ) ) {
        xmmsc_result_unref( res );
        return;
    }

    xmmsc_result_get_dict_entry_string( res, "artist", &artist );
    xmmsc_result_get_dict_entry_string( res, "album", &album );
    xmmsc_result_get_dict_entry_string( res, "title", &title );
    xmmsc_result_get_dict_entry_int( res, "duration", &time_len);
    timeval_to_str( time_len/1000, time_buf, G_N_ELEMENTS(time_buf) );

    gtk_list_store_set( ut->list, &ut->it,
                        COL_ARTIST, artist,
                        COL_ALBUM, album,
                        COL_TITLE, title,
                        COL_LEN, time_buf, -1 );

    g_free( artist );
    g_free( album );
    g_free( title );

    /* xmmsc_result_unref( res ); */
}

static void free_update_track( UpdateTrack* ut )
{
    g_slice_free(UpdateTrack, ut);
}

static void on_playlist_content_received( xmmsc_result_t* res, GtkWidget* list_view )
{
    GtkListStore* list;
    GtkTreeModelFilter* mf;
    GtkTreeIter it;
    const char* pl_name = (char*)g_object_get_data(list_view, "pl_name");

    FilterCriteria* criteria = g_slice_new0(FilterCriteria);

    list = gtk_list_store_new(N_COLS, G_TYPE_INT, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING );
    mf = gtk_tree_model_filter_new(list, NULL);
    g_object_set_data(mf, "criteria", criteria);
    gtk_tree_model_filter_set_visible_func( mf, playlist_filter_func, criteria, filter_criteria_free );
    g_object_unref(list);

    for (; xmmsc_result_list_valid(res); xmmsc_result_list_next(res))
    {
        guint32 id;
        xmmsc_result_t* res2;
        UpdateTrack* ut = g_slice_new(UpdateTrack);

        gtk_list_store_append( list, &it );
        xmmsc_result_get_uint( res, &id );

        gtk_list_store_set( list, &it,
                            COL_ID, id, -1 );

        ut->playlist = pl_name;
        ut->list = list;
        ut->it = it;

        res2 = xmmsc_medialib_get_info( con, id );
        xmmsc_result_notifier_set_full( res2, update_track, ut, free_update_track );
        xmmsc_result_unref( res2 );
    }
    if( GTK_WIDGET_REALIZED( list_view ) )
        gdk_window_set_cursor( list_view->window, NULL );

    gtk_tree_view_set_model( list_view, mf );
    g_object_unref(mf);
}

static void update_play_list( GtkWidget* list_view )
{
    xmmsc_result_t *res;
    const char* pl_name;

    if( GTK_WIDGET_REALIZED( list_view ) ) {
        GdkCursor* cur;
        cur = gdk_cursor_new( GDK_WATCH );
        gdk_window_set_cursor( list_view->window, cur );
        gdk_cursor_unref( cur );
    }
    pl_name = (char*)g_object_get_data(list_view, "pl_name");
    res = xmmsc_playlist_list_entries( con, pl_name );
    xmmsc_result_notifier_set( res, on_playlist_content_received, list_view );
    xmmsc_result_unref(res);
}

static GtkWidget* create_playlist( const char* pl_name )
{
    GtkWidget* list_view;
    GtkTreeSelection* tree_sel;
    GtkTreeViewColumn* col;
    GtkCellRenderer* render;

    list_view = gtk_tree_view_new();
    /* gtk_tree_view_set_rules_hint(list_view, TRUE); */

    g_object_set_data_full(list_view, "pl_name", g_strdup(pl_name), g_free);

    g_signal_connect( list_view, "row-activated",
                      G_CALLBACK( on_playlist_row_activated ), NULL );

    render = gtk_cell_renderer_text_new();
    col = gtk_tree_view_column_new_with_attributes( "#", render, NULL );
    gtk_tree_view_column_set_cell_data_func( col, render, render_num, NULL, NULL );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Artist"), render,
                                                   "text", COL_ARTIST, NULL );
    gtk_tree_view_column_set_fixed_width( col, 80 );
    gtk_tree_view_column_set_sizing( col, GTK_TREE_VIEW_COLUMN_FIXED );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Album"), render,
                                                   "text", COL_ALBUM, NULL );
    gtk_tree_view_column_set_fixed_width( col, 100 );
    gtk_tree_view_column_set_sizing( col, GTK_TREE_VIEW_COLUMN_FIXED );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Title"), render,
                                                   "text", COL_TITLE, NULL );
    gtk_tree_view_column_set_expand( col, TRUE );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    col = gtk_tree_view_column_new_with_attributes( _("Length"), render,
                                                   "text", COL_LEN, NULL );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    gtk_tree_view_set_search_column( (GtkTreeView*)list_view, COL_TITLE );
    tree_sel = gtk_tree_view_get_selection( (GtkTreeView*)list_view );
    gtk_tree_selection_set_mode( tree_sel, GTK_SELECTION_MULTIPLE );

    update_play_list(list_view);
    return list_view;
}

static void add_playlist(const char* pl_name)
{
    GtkWidget* pl, *scroll;
    pl = create_playlist(pl_name);
    scroll = gtk_scrolled_window_new(NULL,NULL);
    gtk_container_add(scroll, pl);
    gtk_scrolled_window_set_policy(scroll, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
    gtk_scrolled_window_set_shadow_type( (GtkScrolledWindow*)scroll, GTK_SHADOW_IN );
    gtk_widget_show_all(scroll);
    gtk_notebook_append_page( notebook, scroll, gtk_label_new(pl_name));
}

static void on_playlist_created( xmmsc_result_t* res, void* user_data )
{
    char* name = (char*)user_data;
    if(  name && name[0] && name[0] != '_' )
        add_playlist(name);
    xmmsc_result_unref(res);
    g_free(name);
}

static void on_playlists_listed( xmmsc_result_t* res, void* user_data )
{
    while( xmmsc_result_list_valid(res) )
    {
        char* str = NULL;
        guint r = xmmsc_result_get_string(res, &str);
        if( str && str[0] && str[0] != '_' )
            add_playlist(str);
        xmmsc_result_list_next(res);
    }
    xmmsc_result_unref(res);

    /* If there is no playlist, create one */
    if( gtk_notebook_get_n_pages(notebook) == 0 )
    {
        char* name = g_strdup(_("Default"));
        res = xmmsc_playlist_create(con, name);
        xmmsc_result_notifier_set(res, on_playlist_created, name);
        xmmsc_result_unref(res);
    }
}

static void on_playlist_content_changed( xmmsc_result_t* res, void* user_data )
{
    guint id = 0;
    int type = 0, pos = -1;
    GtkListStore* list;
    char* name;

    if( G_UNLIKELY( xmmsc_result_iserror( res ) ) )
        return;

    if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_int( res, "type", &type ) ) )
        return;

    if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_string( res, "name", &name ) ) )
        return;

    list = get_playlist_store(name);
    if( ! list )
        return;

    switch( type )
    {
        case XMMS_PLAYLIST_CHANGED_ADD:
        case XMMS_PLAYLIST_CHANGED_INSERT:
            if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
                pos = gtk_tree_model_iter_n_children( (GtkTreeModel*)list, NULL );
            if( G_LIKELY( xmmsc_result_get_dict_entry_uint( res, "id", &id ) ) )
            {
                GtkTreeIter it;
                xmmsc_result_t *res2;
                gtk_list_store_insert_with_values( list, &it, pos,
                                                   COL_ID, id, -1 );
                if( res2 = xmmsc_medialib_get_info( con, id ) )
                {
                    UpdateTrack* ut = g_slice_new(UpdateTrack);
                    /* FIXME: this is dirty */
                    GtkWidget* view = get_playlist_view(name);
                    ut->playlist = (char*)g_object_get_data(view, "pl_name");
                    ut->list = list;
                    ut->it = it;
                    xmmsc_result_notifier_set_full( res2, update_track, ut, free_update_track );
                    xmmsc_result_unref( res2 );
                }
            }
            break;
        case XMMS_PLAYLIST_CHANGED_REMOVE:
            if( G_LIKELY( xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
            {
                GtkTreePath* path;
                GtkTreeIter it;
                path = gtk_tree_path_new_from_indices( pos, -1 );
                if( gtk_tree_model_get_iter( (GtkTreeModel*)list, &it, path ) )
                    gtk_list_store_remove( list, &it );
                gtk_tree_path_free( path );
            }
            break;
        case XMMS_PLAYLIST_CHANGED_CLEAR:
        {
            gtk_list_store_clear( list );
            break;
        }
        case XMMS_PLAYLIST_CHANGED_MOVE:
        {
            int newpos = 0;
            if( G_UNLIKELY( xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
                break;
            if( G_UNLIKELY( xmmsc_result_get_dict_entry_int( res, "newposition", &newpos ) ) )
                break;
            break;
        }
        case XMMS_PLAYLIST_CHANGED_SORT:
        case XMMS_PLAYLIST_CHANGED_SHUFFLE:
        {
            GtkWidget* view = get_playlist_view(name);
            if(view)
                update_play_list( view );
            break;
        }
    }

    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playback_status_changed( xmmsc_result_t *res, void *user_data )
{
    GtkWidget* img;
    if ( !xmmsc_result_get_uint(res, &playback_status) )
    {
        playback_status = XMMS_PLAYBACK_STATUS_STOP;
        return;
    }

    switch( playback_status )
    {
        case XMMS_PLAYBACK_STATUS_PLAY:
            gtk_widget_set_tooltip_text( play_btn, _("Pause") );
            img = gtk_bin_get_child( (GtkBin*)play_btn );
            gtk_image_set_from_stock( (GtkImage*)img, GTK_STOCK_MEDIA_PAUSE,
                                      GTK_ICON_SIZE_BUTTON );
            break;
        case XMMS_PLAYBACK_STATUS_STOP:
            gtk_label_set_text( time_label, "--:--:--" );
            gtk_range_set_value( progress_bar, 0.0 );
        case XMMS_PLAYBACK_STATUS_PAUSE:
            gtk_widget_set_tooltip_text( play_btn, _("Play") );
            img = gtk_bin_get_child( (GtkBin*)play_btn );
            gtk_image_set_from_stock( (GtkImage*)img, GTK_STOCK_MEDIA_PLAY,
                                      GTK_ICON_SIZE_BUTTON );
            break;
    }

    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playback_playtime_changed( xmmsc_result_t* res, void* user_data )
{
    guint time;
    xmmsc_result_t* restart;
    char buf[32];
    if ( xmmsc_result_iserror(res)
         || ! xmmsc_result_get_uint(res, &time))
        return;

    restart = xmmsc_result_restart(res);
    xmmsc_result_unref(res);
    xmmsc_result_unref(restart);

    time /= 1000;
    if( time == play_time )
        return;
    play_time = time;

    gtk_label_set_text( (GtkLabel*)time_label,
                        timeval_to_str( time, buf, G_N_ELEMENTS(buf) ) );

    if( current_track_len > 0 )
    {
        g_signal_handlers_block_by_func(progress_bar, on_progress_bar_changed, user_data);
        gtk_range_set_value( (GtkRange*)progress_bar,
                              (((gdouble)100000 * time) / current_track_len) );
        g_signal_handlers_unblock_by_func(progress_bar, on_progress_bar_changed, user_data);
    }
}

static void on_playback_track_loaded( xmmsc_result_t* res, void* user_data )
{
    char* artist;
    char* title;
    char* tmp;
    if( !xmmsc_result_get_dict_entry_int( res, "duration",
                                          &current_track_len) )
        current_track_len = 0;

    if( !xmmsc_result_get_dict_entry_string( res, "artist", &artist ) )
        artist = NULL;

    if( !xmmsc_result_get_dict_entry_string( res, "title", &title ) )
        title = NULL;

    if( artist )
        tmp = g_strdup_printf( "LXMusic - %s - %s", artist, title );
    else if( title )
        tmp = g_strdup_printf( "LXMusic - %s", title );
    else
        tmp = g_strdup_printf( "LXMusic" );
    g_free(artist);
    g_free(title);
    gtk_window_set_title( main_win, tmp );
    g_free(tmp);
}

static void on_playback_cur_track_changed( xmmsc_result_t* res, void* user_data )
{
    if( xmmsc_result_get_uint(res, &current_id) )
    {
        xmmsc_result_t *res2;
        char* name;
        res2 = xmmsc_medialib_get_info(con, current_id);
        xmmsc_result_notifier_set(res2, on_playback_track_loaded, NULL);
        xmmsc_result_unref(res2);
    }
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playlist_pos_changed( xmmsc_result_t* res, void* user_data )
{
    guint pos;
    GtkTreePath* path;
    GtkTreeSelection* sel;
    guint playlist_pos = 0;

    xmmsc_result_get_uint( res, &playlist_pos );
    g_debug("pos: %s", playlist_pos);
/*
    FIXME: Currently we have no way to mark current played song in the playlist.

    path = gtk_tree_path_new_from_indices( playlist_pos, -1 );
    sel = gtk_tree_view_get_selection( (GtkTreeView*)list_view );
    gtk_tree_selection_select_path( sel, path );
    gtk_tree_path_free( path );
*/
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playback_volume_changed( xmmsc_result_t* res, void* user_data )
{
    guint left, right;
    xmmsc_result_get_dict_entry_uint(res, "left", &left);
    xmmsc_result_get_dict_entry_uint(res, "right", &right);
    {
        g_debug("vol: %d, %d", left, right);
    }
}

static void setup_xmms_callbacks()
{
    xmmsc_result_t* res;
    /* play status */
    res = xmmsc_playback_status(con);
    on_playback_status_changed( res, NULL );
    xmmsc_result_notifier_set(res, on_playback_status_changed, NULL);
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_status,
                       on_playback_status_changed, NULL );

    /* play time */
    /* this is a signal rather than broadcast, so restart is needed in the callback func. */
    XMMS_CALLBACK_SET( con, xmmsc_signal_playback_playtime,
                       on_playback_playtime_changed, NULL);

    /* playlist changed */
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playlist_changed,
                       on_playlist_content_changed, NULL );

    /* current track info */
    res = xmmsc_playback_current_id( con );
    xmmsc_result_notifier_set( res, on_playback_cur_track_changed, NULL );
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_current_id,
                       on_playback_cur_track_changed, NULL );

    /* current pos in playlist */
//    res = xmmsc_playlist_current_pos( con, "_active" );
//    xmmsc_result_notifier_set( res, on_playlist_pos_changed, NULL );
//    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playlist_current_pos,
                       on_playlist_pos_changed, NULL);

    /* volume */
    res = xmmsc_playback_volume_get(con);
    xmmsc_result_notifier_set(res, on_playback_volume_changed, NULL );
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_volume_changed,
                       on_playback_volume_changed, NULL );
}

static void setup_ui()
{
    GtkBuilder *builder;
    GtkWidget *hbox, *cb;
    builder = gtk_builder_new();
    if( ! gtk_builder_add_from_file(builder, PACKAGE_DATA_DIR "/lxmusic/lxmusic.ui", NULL) )
        exit(1);

    main_win = (GtkWidget*)gtk_builder_get_object(builder, "main_win");
    play_btn = (GtkWidget*)gtk_builder_get_object(builder, "play_btn");
    time_label = (GtkWidget*)gtk_builder_get_object(builder, "time_label");
    progress_bar = (GtkWidget*)gtk_builder_get_object(builder, "progress_bar");
    notebook = (GtkWidget*)gtk_builder_get_object(builder, "notebook");
    status_bar = (GtkWidget*)gtk_builder_get_object(builder, "status_bar");

    cb = (GtkWidget*)gtk_builder_get_object(builder, "repeat_mode");
    gtk_combo_box_set_active(cb, repeat_mode);

    cb = (GtkWidget*)gtk_builder_get_object(builder, "filter_field");
    gtk_combo_box_set_active(cb, filter_field);

    /* add volume button */
    hbox = (GtkWidget*)gtk_builder_get_object(builder, "top_hbox");
    volume_btn = gtk_volume_button_new();
    gtk_widget_show(volume_btn);
    gtk_box_pack_start(hbox, volume_btn, FALSE, TRUE, 0);

    /* signal handlers */
    gtk_builder_connect_signals(builder, NULL);

    g_object_unref(builder);
    gtk_widget_show_all(notebook);
    gtk_widget_show (main_win);
}

int main (int argc, char *argv[])
{
    xmmsc_result_t* res;

#ifdef ENABLE_NLS
    bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
    textdomain (GETTEXT_PACKAGE);
#endif

    if( !(con = xmmsc_init ("lxmusic")) )
        return EXIT_FAILURE;

    /* try to connect to xmms2d, and launch the daemon if needed. */
    if( !xmmsc_connect(con, getenv("XMMS_PATH")) )
    {
        if( ! g_spawn_command_line_sync( "xmms2-launcher", NULL, NULL, NULL, NULL )
            || !xmmsc_connect(con, getenv ("XMMS_PATH")) )
        {
            fprintf(stderr, "Connection failed: %s\n",
                     xmmsc_get_last_error (con));
            return EXIT_FAILURE;
        }
    }

    gtk_init(&argc, &argv);
    xmmsc_mainloop_gmain_init(con);

    /* build the GUI */
    setup_ui();

    /* some dirty hacks to show the window earlier :-D */
    while( gtk_events_pending() )
        gtk_main_iteration();
    gdk_display_sync(gtk_widget_get_display(main_win));

    /* load all existing playlists */
    res = xmmsc_playlist_list( con );
    xmmsc_result_notifier_set(res, on_playlists_listed, NULL);
    xmmsc_result_unref(res);

    /* register callbacks */
    setup_xmms_callbacks();

    gtk_main ();

    return 0;
}

