/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xmmsclient/xmmsclient.h>
#include <xmmsclient/xmmsclient-glib.h>

#include "utils.h"

enum {
    COL_ID = 0,
    COL_ARTIST,
    COL_ALBUM,
    COL_TITLE,
    COL_LEN,
    N_COLS
};

enum {
    REPEAT_NONE,
    REPEAT_CURRENT,
    REPEAT_ALL
};

enum {
    FILTER_ALL,
    FILTER_TITLE,
    FILTER_ARTIST,
    FILTER_ALBUM
};

typedef struct _UpdateTrack{
    guint32 id;
    GtkTreeIter it;
}UpdateTrack;

typedef struct _FilterCriteria{
    char* keyword;
    int cols;
}FilterCriteria;

const char* known_plugins[] = {
    "pulse",
    "alsa",
    "ao"
};

static xmmsc_connection_t *con = NULL;
static GtkWidget *main_win = NULL;
static GtkWidget *tray_icon = NULL;
static GtkWidget *play_btn = NULL;
static GtkWidget *time_label = NULL;
static GtkWidget *progress_bar = NULL;
static GtkWidget *status_bar = NULL;
static GtkWidget *notebook = NULL;
static GtkWidget *volume_btn = NULL;
static GtkWidget *inner_vbox = NULL;
static GtkWidget *playlist_view = NULL;
static GtkWidget *repeat_mode_cb = NULL;

static GtkWidget *switch_pl_menu = NULL;
static GSList* switch_pl_menu_group = NULL;

static GtkWidget *add_to_pl_menu = NULL;
static GtkWidget *rm_from_pl_menu = NULL;

static char* cur_playlist = NULL;
static GSList* all_playlists = NULL;

static GQueue* pending_update_tracks = NULL;
static GtkListStore* list_store = NULL;

static guint playback_status = 0;
static guint play_time = 0;
static guint cur_track_duration = 0;
static guint cur_track_id = 0;

static int repeat_mode = REPEAT_NONE;

/* config values */
static gboolean show_tray_icon = TRUE;
static gboolean show_playlist = TRUE;
static gboolean close_to_tray = TRUE;

static int filter_field = FILTER_ALL;
static guint32 volume = 60;

/* window size */
static int win_width = 480;
static int win_height = 320;


/* used to debug only */
static void dict_foreach(const void *key, xmmsc_result_value_type_t type, const void *value, void *user_data)
{
    g_debug("key=%s, type=%d", key, type);
}

static void load_config()
{
    char* path = g_build_filename(g_get_user_config_dir(), "lxmusic", "config", NULL );
    GKeyFile* kf = g_key_file_new();
    if( g_key_file_load_from_file(kf, path, 0, NULL) )
    {
        int v;
        const char grp[] = "Main";
        v = g_key_file_get_integer(kf, grp, "width", NULL);
        if( v > 0 )
            win_width = v;
        v = g_key_file_get_integer(kf, grp, "height", NULL);
        if( v > 0 )
            win_height = v;
        kf_get_bool(kf, grp, "show_tray_icon", &show_tray_icon);
        kf_get_bool(kf, grp, "show_playlist", &show_playlist);
        kf_get_bool(kf, grp, "close_to_tray", &close_to_tray);
        filter_field = g_key_file_get_integer(kf, grp, "filter", NULL);
        if(g_key_file_has_key(kf, grp, "volume", NULL))
            volume = g_key_file_get_integer(kf, grp, "volume", NULL);
    }
    g_free(path);
    g_key_file_free(kf);
}

static void save_config()
{
    FILE* f;
    char* dir = g_build_filename(g_get_user_config_dir(), "lxmusic", NULL);
    char* path = g_build_filename(dir, "config", NULL );

    g_mkdir_with_parents(dir, 0700);
    g_free( dir );

    f = fopen(path, "w");
    g_free(path);
    if( f )
    {
        fprintf(f, "[Main]\n");
        fprintf( f, "width=%d\n", win_width );
        fprintf( f, "height=%d\n", win_height );
        fprintf( f, "show_tray_icon=%d\n", show_tray_icon );
        fprintf( f, "show_playlist=%d\n", show_playlist );
        fprintf( f, "filter=%d\n", filter_field );
        fprintf( f, "volume=%d\n", (int)volume );
        fclose(f);
    }
}

/*
static GtkListStore* get_playlist_store()
{
    GtkTreeModel* filter = gtk_tree_view_get_model(playlist_view);
    if( filter )
        return gtk_tree_model_filter_get_model((GtkTreeModelFilter*)filter);
    return NULL;
}
*/

static void filter_criteria_free( FilterCriteria* f )
{
    g_free(f->keyword);
    g_slice_free(FilterCriteria, f);
}

static void free_update_track( UpdateTrack* ut )
{
    g_slice_free(UpdateTrack, ut);
}

static void cancel_pending_update_tracks()
{
    /* g_debug("try to cancel"); */
    if( ! g_queue_is_empty(pending_update_tracks) )
    {
        g_queue_foreach(pending_update_tracks, free_update_track, NULL);
        g_queue_clear(pending_update_tracks);
    }
}

void on_quit(GtkAction* act, gpointer user_data)
{
    cancel_pending_update_tracks();

    if( show_playlist )
        gtk_window_get_size(main_win, &win_width, &win_height);

    gtk_widget_destroy(main_win);
    gtk_main_quit();
}

gboolean on_main_win_delete_event(GtkWidget* win, GdkEvent* evt, gpointer user_data)
{
    on_quit(NULL, NULL);
    return FALSE;
}

void on_main_win_destroy(GtkWidget* win)
{
}

static void open_url(GtkAboutDialog* dlg, const char* url, gpointer user_data)
{
    const char* argv[] = {"xdg-open", NULL, NULL};
    argv[1] = url;
    g_spawn_async("/", argv, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, NULL);
}

void on_about(GtkWidget* mi, gpointer data)
{
    const char* authors[] = { "洪任諭 (Hong Jen Yee) <pcman.tw@gmail.com>", NULL };
    const char* artists[] = { N_("Official icon of xmms2 by Arnaud DIDRY"), NULL };
    GtkWidget* about;

    gtk_about_dialog_set_url_hook(open_url, NULL, NULL);

    about = gtk_about_dialog_new();
    gtk_about_dialog_set_name( (GtkAboutDialog*)about, "LXMusic" );
    gtk_about_dialog_set_logo_icon_name(about, "lxmusic");
    gtk_about_dialog_set_version( (GtkAboutDialog*)about, VERSION );
    gtk_about_dialog_set_authors( (GtkAboutDialog*)about, authors );
    gtk_about_dialog_set_artists( (GtkAboutDialog*)about, artists );
    gtk_about_dialog_set_comments( (GtkAboutDialog*)about, _("Music Player for LXDE\nSimple GUI XMMS2 client") );
    gtk_about_dialog_set_license( (GtkAboutDialog*)about, "GNU General Public License" );
    gtk_about_dialog_set_website( (GtkAboutDialog*)about, "http://lxde.org/" );
    gtk_window_set_transient_for( (GtkWindow*)about, (GtkWindow*)main_win );
    gtk_dialog_run( (GtkDialog*)about );
    gtk_widget_destroy( about );
}

static void on_pref_dlg_init_widget(xmmsc_result_t* res, void* user_data)
{
    GtkWidget* w = (GtkWidget*)user_data;
    char* val;
    if( xmmsc_result_get_string(res, &val) )
    {
        /* g_debug("val = %s, w is a %s", val, G_OBJECT_TYPE_NAME(w)); */
        if( GTK_IS_SPIN_BUTTON(w) )
            gtk_spin_button_set_value(w, atoi(val));
        else if( GTK_IS_ENTRY(w) )
            gtk_entry_set_text(w, val);
        else if( GTK_IS_COMBO_BOX_ENTRY(w) )
            gtk_entry_set_text(gtk_bin_get_child(w), val);
        else
            g_debug("%s is not supported", G_OBJECT_TYPE_NAME(w));
    }
    xmmsc_result_unref(res);
}

static void on_pref_dlg_init_output_plugin(xmmsc_result_t* res, void* user_data)
{
    GtkWidget* w = (GtkWidget*)user_data;
    char* val;
    if( xmmsc_result_get_string(res, &val) )
    {
        int i;
        for( i=0; i < G_N_ELEMENTS(known_plugins); ++i )
        {
            if( strcmp(val, known_plugins[i]) == 0 )
            {
                gtk_combo_box_set_active(w, i);
                break;
            }
        }
    }
    xmmsc_result_unref(res);
}

static void on_tray_icon_activate(GtkStatusIcon* icon, gpointer user_data)
{
    /* FIXME: should we unload the playlist to free resources here? */
    if( GTK_WIDGET_VISIBLE(main_win) )
        gtk_widget_hide(main_win);
    else
        gtk_widget_show(main_win);
}

static void on_tray_icon_popup_menu(GtkStatusIcon* icon, guint btn, guint time, gpointer user_data)
{

}

static void create_tray_icon()
{
    tray_icon = gtk_status_icon_new_from_icon_name("lxmusic");
    gtk_status_icon_set_tooltip(tray_icon, _("LXMusic"));
    g_signal_connect(tray_icon, "activate", G_CALLBACK(on_tray_icon_activate), NULL );
    g_signal_connect(tray_icon, "popup-menu", G_CALLBACK(on_tray_icon_popup_menu), NULL );
}


void on_preference(GtkAction* act, gpointer data)
{
    GtkBuilder* builder = gtk_builder_new();
    if( gtk_builder_add_from_file(builder, PACKAGE_DATA_DIR "/lxmusic/pref-dlg.ui", NULL ) )
    {
        xmmsc_result_t* res;
        GtkWidget* show_tray_icon_btn = gtk_builder_get_object(builder, "show_tray_icon");
        GtkWidget* output_plugin_cb = gtk_builder_get_object(builder, "output_plugin_cb");
        GtkWidget* output_bufsize = gtk_builder_get_object(builder, "output_bufsize");
        GtkWidget* cdrom = gtk_builder_get_object(builder, "cdrom");
        GtkWidget* id3v1_encoding = gtk_builder_get_object(builder, "id3v1_encoding");
        GtkWidget* dlg = gtk_builder_get_object(builder, "pref_dlg");

        gtk_toggle_button_set_active(show_tray_icon_btn, show_tray_icon);

        res = xmmsc_configval_get(con, "output.plugin");
        xmmsc_result_notifier_set_full(res, on_pref_dlg_init_output_plugin, g_object_ref(output_plugin_cb), g_object_unref );
        xmmsc_result_unref(res);

        res = xmmsc_configval_get(con, "output.buffersize");
        xmmsc_result_notifier_set_full(res, on_pref_dlg_init_widget, g_object_ref(output_bufsize), g_object_unref );
        xmmsc_result_unref(res);

        res = xmmsc_configval_get(con, "cdda.device");
        xmmsc_result_notifier_set_full(res, on_pref_dlg_init_widget, g_object_ref(cdrom), g_object_unref );
        xmmsc_result_unref(res);

        res = xmmsc_configval_get(con, "mad.id3v1_encoding");
        xmmsc_result_notifier_set_full(res, on_pref_dlg_init_widget, g_object_ref(id3v1_encoding), g_object_unref );
        xmmsc_result_unref(res);

        if( gtk_dialog_run(dlg) == GTK_RESPONSE_OK )
        {
            int i;
            char str[32];

            i = gtk_combo_box_get_active(output_plugin_cb);
            res = xmmsc_configval_set( con, "output.plugin", known_plugins[i] );
            xmmsc_result_unref(res);

            g_snprintf(str, 32, "%u",(guint)gtk_spin_button_get_value(output_bufsize) );
            res = xmmsc_configval_set( con, "output.buffersize", str );
            xmmsc_result_unref(res);

            res = xmmsc_configval_set( con, "cdda.device", gtk_entry_get_text(cdrom) );
            xmmsc_result_unref(res);

            res = xmmsc_configval_set( con, "mad.id3v1_encoding", gtk_entry_get_text(id3v1_encoding) );
            xmmsc_result_unref(res);

            show_tray_icon = gtk_toggle_button_get_active(show_tray_icon_btn);
            if( show_tray_icon )
            {
                if( ! tray_icon )
                    create_tray_icon();
            }
            else
            {
                if( tray_icon )
                {
                    g_object_unref(tray_icon);
                    tray_icon = NULL;
                }
            }
        }
        gtk_widget_destroy(dlg);
    }
    g_object_unref(builder);
}

static void on_track_info_received(xmmsc_result_t* res, void* user_data)
{
    GtkBuilder* builder = (GtkBuilder*)user_data;
    GtkWidget* w;
    const char* keys[] = {
        "title", "album", "artist", "comment", "bitrate", NULL
    };
    const char** key;
    char* val;

    if( xmmsc_result_get_dict_entry_string(res, "url", &val) )
    {
        w = (GtkWidget*)gtk_builder_get_object(builder, "url");
        if( g_str_has_prefix(val, "file://") )
        {
            char* fn = g_filename_from_uri(val, NULL, NULL);
            if( fn )
            {
                char* disp = g_filename_display_name(fn);
                g_free(fn);
                gtk_entry_set_text(w, disp);
                g_free(disp);
            }
            else
                gtk_entry_set_text(w, val);
        }
        else
            gtk_entry_set_text(w, val);
    }

    for(key = keys; *key; ++key)
    {
        if( xmmsc_result_get_dict_entry_string(res, *key, &val) )
        {
            w = (GtkWidget*)gtk_builder_get_object(builder, *key);
            if( GTK_IS_ENTRY(w) )
                gtk_entry_set_text((GtkEntry*)w, val);
            else if( GTK_IS_LABEL(w) )
                gtk_label_set_text((GtkLabel*)w, val);
        }
    }
}

void on_file_properties(GtkAction* act, gpointer data)
{
    GtkTreeSelection* sel = gtk_tree_view_get_selection(playlist_view);
    GtkTreeIter it;
    GtkTreeModel* model;
    GList* rows;
    if( rows = gtk_tree_selection_get_selected_rows(sel, &model) )
    {
        GtkTreePath* tp = (GtkTreePath*)rows->data;
        if( gtk_tree_model_get_iter(model, &it, tp) )
        {
            GtkBuilder* builder = gtk_builder_new();
            guint id;
            gtk_tree_model_get( model, &it, COL_ID, &id, -1 );
            if( gtk_builder_add_from_file(builder, PACKAGE_DATA_DIR "/lxmusic/track-info.ui", NULL ) )
            {
                xmmsc_result_t* res;
                GtkWidget* dlg = (GtkWidget*)gtk_builder_get_object(builder, "track_info_dlg");
                gtk_builder_connect_signals(builder, NULL);

                res = xmmsc_medialib_get_info(con, id);
                xmmsc_result_notifier_set_full(res, on_track_info_received, g_object_ref(builder), g_object_unref);
                xmmsc_result_unref(res);

                gtk_window_present(dlg);
            }
            g_object_unref(builder);
        }
        g_list_free(rows);
    }
}

void on_playlist_row_activated(GtkTreeView* view,
                              GtkTreePath* path,
                              GtkTreeViewColumn* col,
                              gpointer user_data)
{
    xmmsc_result_t* res;
    GtkTreeModelFilter* filter = (GtkTreeModelFilter*)gtk_tree_view_get_model(view);
    /* convert from model filter path to path of underlying liststore */
    path = gtk_tree_model_filter_convert_path_to_child_path(filter, path);
    if( path )
    {
        guint pos = gtk_tree_path_get_indices(path)[0];
        /* FIXME: need to swtich to another playlist sometimes. */
        res = xmmsc_playlist_set_next( con, pos );
        xmmsc_result_unref(res);

        res = xmmsc_playback_tickle(con);
        xmmsc_result_unref(res);

        /* FIXME: just call play is not enough? */
        if( playback_status != XMMS_PLAYBACK_STATUS_PLAY )
            on_play_btn_clicked(play_btn, NULL);
        gtk_tree_path_free(path);
    }
}

void on_filter_field_changed(GtkComboBox* cb, gpointer user_data)
{
    filter_field = gtk_combo_box_get_active(cb);
}

static gboolean playlist_filter_func(GtkTreeModel* model, GtkTreeIter* it, FilterCriteria* criteria)
{
    char *artist, *album, *title;
    gboolean ret = FALSE;

    if( ! criteria->keyword )
        return TRUE;

    gtk_tree_model_get(model, it,
                       COL_ARTIST, &artist,
                       COL_ALBUM, &album,
                       COL_TITLE, &title, -1);

    if( artist && strstr( artist, criteria->keyword ) )
        ret = TRUE;
    else if( album && strstr( album, criteria->keyword ) )
        ret = TRUE;
    else if( title && strstr( title, criteria->keyword ) )
        ret = TRUE;

    g_free(artist);
    g_free(album);
    g_free(title);

    return ret;
}

void on_filter_entry_changed(GtkEntry* entry, gpointer user_data)
{
    GtkWidget* view = playlist_view;
    GtkTreeModelFilter* filter = (GtkTreeModelFilter*)gtk_tree_view_get_model(view);
    FilterCriteria* criteria = (FilterCriteria*)g_object_get_data(filter, "criteria");
    g_free(criteria->keyword);
    criteria->keyword = g_strdup(gtk_entry_get_text(entry));
    gtk_tree_model_filter_refilter(filter);

    /* FIXME: keep selections and keep the selected items visible in current view. */
}

static gboolean file_filter_fnuc(const GtkFileFilterInfo *inf, gpointer user_data)
{
    return g_str_has_prefix(inf->mime_type, "audio/");
}

static gpointer add_file( const char* file )
{
    gboolean is_dir = g_file_test( file, G_FILE_TEST_IS_DIR );
    xmmsc_result_t *res;
    char *url;

    /* Since xmms2 uses its own url format, this is annoying but inevitable. */
    url = g_strconcat( "file://", file, NULL );

    if( is_dir )
        res = xmmsc_playlist_radd( con, cur_playlist, url );
    else
        res = xmmsc_playlist_add_url( con, cur_playlist, url );
    g_free( url );

    if( res )
        xmmsc_result_unref( res );
    return NULL;
}

void on_add_files( GtkMenuItem* item, gpointer user_data )
{
    enum { RESPONSE_ADD = 1 };
    GtkWidget *dlg = gtk_file_chooser_dialog_new( NULL, (GtkWindow*)main_win,
                                                  GTK_FILE_CHOOSER_ACTION_OPEN,
                                                  GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                  GTK_STOCK_ADD, RESPONSE_ADD, NULL );
    GtkFileFilter* filter;

    gtk_file_chooser_set_select_multiple( (GtkFileChooser*)dlg, TRUE );

    /* add a custom filter which filters autio files */
    filter = gtk_file_filter_new();
    gtk_file_filter_set_name(filter, _("Audio Files"));
    gtk_file_filter_add_custom( filter, GTK_FILE_FILTER_MIME_TYPE, file_filter_fnuc, NULL, NULL );
    gtk_file_chooser_add_filter(dlg, filter);

    filter = gtk_file_filter_new();
    gtk_file_filter_set_name(filter, _("All Files"));
    gtk_file_filter_add_custom( filter, 0, gtk_true, NULL, NULL );
    gtk_file_chooser_add_filter(dlg, filter);

    if( gtk_dialog_run( (GtkDialog*)dlg ) == RESPONSE_ADD )
    {
        GSList* uris = gtk_file_chooser_get_uris( (GtkFileChooser*)dlg );
        GSList* uri;

        if( ! uris )
            return;

        for( uri = uris; uri; uri = uri->next )
        {
            gchar* file = g_filename_from_uri( uri->data, NULL, NULL );
            add_file( file );
            g_free( file );
            g_free( uri->data );
        }
        g_slist_free( uris );
    }
    gtk_widget_destroy( dlg );
}

void on_add_url( GtkMenuItem* item, gpointer user_data )
{
    GtkWidget *dlg = gtk_dialog_new_with_buttons(
            _("Input a URL"), (GtkWindow*)main_win, GTK_DIALOG_MODAL,
            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
            GTK_STOCK_OK, GTK_RESPONSE_OK, NULL );
    GtkWidget *entry = gtk_entry_new();
    gtk_box_pack_start( (GtkBox*)((GtkDialog*)dlg)->vbox, entry, FALSE, FALSE, 4 );
    gtk_dialog_set_default_response( (GtkDialog*)dlg, GTK_RESPONSE_OK );
    gtk_entry_set_activates_default( (GtkEntry*)entry, TRUE );
    gtk_widget_show_all( dlg );
    if( gtk_dialog_run( (GtkDialog*)dlg ) == GTK_RESPONSE_OK )
    {
        xmmsc_result_t *res;
        const char* url = gtk_entry_get_text( (GtkEntry*)entry );
        res = xmmsc_playlist_add_url( con, "_active", url );
        xmmsc_result_unref( res );
    }
    gtk_widget_destroy( dlg );
}

static void on_add_from_mlib( GtkMenuItem* item, gpointer user_data )
{
    /* FIXME: This might be implemented in the future */
}

void on_add_btn_clicked(GtkButton* btn, gpointer user_data)
{
    gtk_menu_popup(add_to_pl_menu, NULL, NULL, NULL, NULL, 1, GDK_CURRENT_TIME );
}

static int intcmp( gconstpointer a, gconstpointer b )
{
    return (int)b - (int)a;
}

void on_remove_all(GtkAction* act, gpointer user_data)
{
    xmmsc_result_t* res;
    res = xmmsc_playlist_clear(con, cur_playlist);
    xmmsc_result_unref(res);
}

void on_remove_selected(GtkAction* act, gpointer user_data)
{
    xmmsc_result_t* res;
    if( cur_playlist )
    {
        GtkTreeSelection* tree_sel;
        tree_sel = gtk_tree_view_get_selection( (GtkTreeView*)playlist_view );
        GList *sels = gtk_tree_selection_get_selected_rows( tree_sel, NULL );
        GList *sel;
        if( ! sels )
            return;

        for( sel = sels; sel; sel = sel->next )
        {
            GtkTreePath* path = (GtkTreePath*)sel->data;
            sel->data = (gpointer)gtk_tree_path_get_indices( path )[0];
            gtk_tree_path_free( path );
        }

        /*
            sort the list, and put rows with bigger indicies before those with smaller indicies.
            In this way, all indicies won't be changed during removing items.
        */
        sels = g_list_sort( sels, intcmp );

        for( sel = sels; sel; sel = sel->next )
        {
            xmmsc_result_t* res;
            int pos = (int)sel->data;
            res = xmmsc_playlist_remove_entry( con, cur_playlist, pos );
            xmmsc_result_unref( res );
        }
        g_list_free( sels );
    }
}

void on_remove_btn_clicked(GtkButton* btn, gpointer user_data)
{
    gtk_menu_popup(rm_from_pl_menu, NULL, NULL, NULL, NULL, 1, GDK_CURRENT_TIME );
}

void on_repeat_mode_changed(GtkComboBox* cb, gpointer user_data)
{
    xmmsc_result_t* res;
    const char* repeat_one = "0";
    const char* repeat_all = "0";
    switch(gtk_combo_box_get_active(cb))
    {
    case REPEAT_CURRENT:
        repeat_one = "1";
        break;
    case REPEAT_ALL:
        repeat_all = "1";
        break;
    }
    res = xmmsc_configval_set(con, "playlist.repeat_all", repeat_all);
    xmmsc_result_unref(res);
    res = xmmsc_configval_set(con, "playlist.repeat_one", repeat_one);
    xmmsc_result_unref(res);
}

void on_progress_bar_changed(GtkScale* bar, gpointer user_data)
{
    xmmsc_result_t* res;
    gdouble p = gtk_range_get_value(bar);
    guint new_play_time = p * cur_track_duration / 100;
    res = xmmsc_playback_seek_ms( con, new_play_time );
    xmmsc_result_unref(res);
}

void on_prev_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playlist_set_next_rel(con, -1);
    xmmsc_result_unref(res);
    res = xmmsc_playback_tickle(con);
    xmmsc_result_unref(res);
}

void on_next_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playlist_set_next_rel(con, 1);
    xmmsc_result_unref(res);
    res = xmmsc_playback_tickle(con);
    xmmsc_result_unref(res);
}

void on_play_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t *res;
    if( playback_status == XMMS_PLAYBACK_STATUS_PLAY )
    {
        res = xmmsc_playback_pause(con);
        xmmsc_result_unref(res);
    }
    else
    {
        res = xmmsc_playback_start(con);
        xmmsc_result_unref(res);
    }
}

void on_stop_btn_clicked(GtkButton* btn, gpointer user_data)
{
    xmmsc_result_t* res = xmmsc_playback_stop(con);
    xmmsc_result_unref(res);
}


static void render_num( GtkTreeViewColumn* col, GtkCellRenderer* render,
                        GtkTreeModel* model, GtkTreeIter* it, gpointer data )
{
    GtkTreePath* path = gtk_tree_model_get_path( model, it );
    char buf[16];
    if( G_UNLIKELY( ! path ) )
        return;
    g_sprintf( buf, "%d", gtk_tree_path_get_indices( path )[0] + 1 );
    gtk_tree_path_free( path );
    g_object_set( render, "text", buf, NULL );
}

static const char* timeval_to_str( guint timeval, char* buf, guint buf_len )
{
    guint hr, min, sec;

    hr = timeval / 3600;
    min = timeval % 3600;
    sec = min % 60;
    min /= 60;
    if( hr > 0 )
        g_snprintf( buf, buf_len, "%.2u:%.2u:%.2u", hr, min, sec );
    else
        g_snprintf( buf, buf_len, "%.2u:%.2u", min, sec );

    return buf;
}

static void update_track( xmmsc_result_t *res, UpdateTrack* ut )
{
    char *artist, *album, *title;
    guint time_len = 0;
    char time_buf[32];
    /* g_debug("do update track: %d", ut->id); */

    /* OK, now it's time to send the next request.
     * This is inefficient, but it's used to overcome
     * some design flaws of xmms2d.
     * Some optimization can be done here by send about
     * 10 requets or so at the same time. */
    if( ! g_queue_is_empty(pending_update_tracks) )
    {
        xmmsc_result_t* res2;
        UpdateTrack* ut = (UpdateTrack*)g_queue_pop_head(pending_update_tracks);

        res2 = xmmsc_medialib_get_info( con, ut->id );
        xmmsc_result_notifier_set_full( res2, update_track, ut, free_update_track );
        xmmsc_result_unref( res2 );
    }

    if( xmmsc_result_iserror( res ) ) {
        xmmsc_result_unref( res );
        return;
    }

    xmmsc_result_get_dict_entry_string( res, "artist", &artist );
    xmmsc_result_get_dict_entry_string( res, "album", &album );
    xmmsc_result_get_dict_entry_string( res, "title", &title );
    xmmsc_result_get_dict_entry_int( res, "duration", &time_len);
    timeval_to_str( time_len/1000, time_buf, G_N_ELEMENTS(time_buf) );

    /* use file name to replace track name if it doesn't have id3. */
    if( !title )
    {
        char *url, *file;
        xmmsc_result_get_dict_entry_string( res, "url", &url );
        file = g_filename_from_uri(url, NULL, NULL);
        title = g_path_get_basename(file);
        g_free(file);
    }

    gtk_list_store_set( list_store, &ut->it,
                        COL_ARTIST, artist,
                        COL_ALBUM, album,
                        COL_TITLE, title,
                        COL_LEN, time_buf, -1 );

    xmmsc_result_unref( res );
}

static void queue_update_track( guint32 id, GtkTreeIter* it )
{
    UpdateTrack* ut;
    /* if it's already in the queue */
    if( ! g_queue_is_empty( pending_update_tracks ) )
    {
        GList* l;
        for( l = pending_update_tracks->head; l; l = l->next )
        {
            ut = (UpdateTrack*)l->data;
            if( id == ut->id )
                return;
        }
    }

    ut = g_slice_new(UpdateTrack);
    ut->id = id;
    ut->it = *it;

    if( g_queue_is_empty( pending_update_tracks ) )
    {
        xmmsc_result_t *res;
        res = xmmsc_medialib_get_info( con, id );
        xmmsc_result_notifier_set_full( res, update_track, ut, free_update_track );
        xmmsc_result_unref( res );
    }
    else
    {
        g_queue_push_tail(pending_update_tracks, ut);
    }
}

static void on_playlist_content_received( xmmsc_result_t* res, GtkWidget* list_view )
{
    GtkTreeModelFilter* mf;
    GtkTreeIter it;
    const char* pl_name = cur_playlist;

    FilterCriteria* criteria = g_slice_new0(FilterCriteria);

    list_store = gtk_list_store_new(N_COLS, G_TYPE_INT, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING );
    mf = gtk_tree_model_filter_new(list_store, NULL);
    g_object_set_data(mf, "criteria", criteria);
    gtk_tree_model_filter_set_visible_func( mf, playlist_filter_func, criteria, filter_criteria_free );
    g_object_unref(list_store);

    cancel_pending_update_tracks();

    for (; xmmsc_result_list_valid(res); xmmsc_result_list_next(res))
    {
        guint32 id;
        xmmsc_result_t* res2;
        UpdateTrack* ut = g_slice_new(UpdateTrack);

        gtk_list_store_append( list_store, &it );
        xmmsc_result_get_uint( res, &id );

        gtk_list_store_set( list_store, &it,
                            COL_ID, id, -1 );

        ut->id = id;
        ut->it = it;
        /* add this request to pending list */
        g_queue_push_tail( pending_update_tracks, ut );
    }

    if( !g_queue_is_empty(pending_update_tracks) )
    {
        UpdateTrack* ut = (UpdateTrack*)g_queue_pop_head(pending_update_tracks);
        /* only send the first request, and subsequent requests will
         * be sent after the previous one is returned. */
        res = xmmsc_medialib_get_info( con, ut->id );
        xmmsc_result_notifier_set_full( res, update_track, ut, free_update_track );
        xmmsc_result_unref( res );
    }

    if( GTK_WIDGET_REALIZED( list_view ) )
        gdk_window_set_cursor( list_view->window, NULL );

    gtk_tree_view_set_model( list_view, mf );

    /* select the first item */
    if( gtk_tree_model_get_iter_first(mf, &it) )
    {
        GtkTreeSelection* sel = gtk_tree_view_get_selection(list_view);
        gtk_tree_selection_select_iter(sel, &it);
    }

    g_object_unref(mf);
}

static void on_playlist_get_active(xmmsc_result_t* res, void* user_data)
{
    char* name;
    if( xmmsc_result_get_string(res, &name) )
    {
        g_free(cur_playlist);
        cur_playlist = g_strdup(name);
    }
    xmmsc_result_unref(res);
}

static void update_play_list( GtkWidget* list_view )
{
    xmmsc_result_t *res;
    const char* pl_name;

    if( GTK_WIDGET_REALIZED( list_view ) ) {
        GdkCursor* cur;
        cur = gdk_cursor_new( GDK_WATCH );
        gdk_window_set_cursor( list_view->window, cur );
        gdk_cursor_unref( cur );
    }
    res = xmmsc_playlist_list_entries( con, cur_playlist );
    xmmsc_result_notifier_set( res, on_playlist_content_received, list_view );
    xmmsc_result_unref(res);
}

static GtkWidget* init_playlist(GtkWidget* list_view)
{
    GtkTreeSelection* tree_sel;
    GtkTreeViewColumn* col;
    GtkCellRenderer* render;

    render = gtk_cell_renderer_text_new();
    col = gtk_tree_view_column_new_with_attributes( "#", render, NULL );
    gtk_tree_view_column_set_cell_data_func( col, render, render_num, NULL, NULL );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Artist"), render,
                                                   "text", COL_ARTIST, NULL );
    gtk_tree_view_column_set_fixed_width( col, 80 );
    gtk_tree_view_column_set_sizing( col, GTK_TREE_VIEW_COLUMN_FIXED );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Album"), render,
                                                   "text", COL_ALBUM, NULL );
    gtk_tree_view_column_set_fixed_width( col, 100 );
    gtk_tree_view_column_set_sizing( col, GTK_TREE_VIEW_COLUMN_FIXED );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    g_object_set( render, "ellipsize", PANGO_ELLIPSIZE_END, NULL );
    col = gtk_tree_view_column_new_with_attributes( _("Title"), render,
                                                   "text", COL_TITLE, NULL );
    gtk_tree_view_column_set_expand( col, TRUE );
    gtk_tree_view_column_set_resizable( col, TRUE );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    render = gtk_cell_renderer_text_new();
    col = gtk_tree_view_column_new_with_attributes( _("Length"), render,
                                                   "text", COL_LEN, NULL );
    gtk_tree_view_append_column( (GtkTreeView*)list_view, col );

    gtk_tree_view_set_search_column( (GtkTreeView*)list_view, COL_TITLE );
    tree_sel = gtk_tree_view_get_selection( (GtkTreeView*)list_view );
    gtk_tree_selection_set_mode( tree_sel, GTK_SELECTION_MULTIPLE );

    return list_view;
}

static void on_switch_to_playlist(GtkWidget* mi, char* pl_name)
{
    xmmsc_result_t* res;
    if( gtk_check_menu_item_get_active(mi) )
    {
        /* if there are pending requests to current playlist, cancel them */
        cancel_pending_update_tracks();

        res = xmmsc_playlist_load(con, pl_name);
        xmmsc_result_unref(res);
    }
}

static void on_playlist_loaded(xmmsc_result_t* res, gpointer user_data)
{
    char* name;
    if( !xmmsc_result_iserror(res) && xmmsc_result_get_string(res, &name) )
    {
        /* FIXME: is this possible? */
        if( cur_playlist && 0 == strcmp((char*)name, cur_playlist) )
            return;

        g_free(cur_playlist);
        cur_playlist = g_strdup(name);

        /* update the menu */
        if( cur_playlist )
        {
            GSList* l;
            for( l = switch_pl_menu_group; l; l=l->next )
            {
                GtkRadioMenuItem* mi = (GtkRadioMenuItem*)l->data;
                char* pl_name = (char*)g_object_get_data(mi, "pl_name");
                if( strcmp(cur_playlist, pl_name) == 0 )
                {
                    g_signal_handlers_block_by_func(mi, on_switch_to_playlist, pl_name);
                    gtk_check_menu_item_set_active(mi, TRUE);
                    g_signal_handlers_unblock_by_func(mi, on_switch_to_playlist, pl_name);
                    break;
                }
            }
        }

        /* if there are pending requests, cancel them */
        cancel_pending_update_tracks();

        update_play_list( playlist_view );
    }
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void add_playlist_to_menu(const char* pl_name, gboolean need_sort)
{
    GtkWidget* mi = gtk_radio_menu_item_new_with_label(switch_pl_menu_group, pl_name);
    char* name = g_strdup(pl_name);
    switch_pl_menu_group = gtk_radio_menu_item_get_group(mi);
    g_object_set_data_full(mi, "pl_name", name, g_free);
    g_signal_connect( mi, "toggled", G_CALLBACK(on_switch_to_playlist), name);
    gtk_widget_show(mi);

    if( need_sort )
    {
        GSList* l;
        int i = 0;
        for(l=all_playlists; l; l = l->next, ++i)
        {
            if( g_utf8_collate(pl_name, (char*)l->data) < 0 )
                break;
        }
        gtk_menu_shell_insert(switch_pl_menu, mi, i);
        all_playlists = g_slist_insert(all_playlists, name, i);
    }
    else
    {
        gtk_menu_shell_append(switch_pl_menu, mi);
        all_playlists = g_slist_append(all_playlists, name );
    }

    /* toggle the menu item. This can trigger the load of the list into tree view */
    if( cur_playlist && 0 == strcmp(pl_name, cur_playlist) )
        gtk_check_menu_item_set_active(mi, TRUE);
}

static void remove_playlist_from_menu(const char* pl_name)
{
    GSList* l;
    l = g_slist_find_custom(all_playlists, pl_name, (GCompareFunc)strcmp);
    all_playlists = g_slist_delete_link(all_playlists, l);

    for( l = switch_pl_menu_group; l; l = l->next )
    {
        GtkRadioMenuItem* mi = (GtkRadioMenuItem*)l->data;
        char* name = (char*)g_object_get_data(mi, "pl_name");
        if( name && strcmp(name, pl_name)==0 )
            break;
    }
    if( l )
    {
        /* switch_pl_menu_group might be out of date here. */
        if( l == switch_pl_menu_group )
            switch_pl_menu_group = l->next;
        gtk_widget_destroy(GTK_WIDGET(l->data));
    }
    /* FIXME: should we load another playlist here if the removed one is
     * the current one in use? */
}

static void on_playlist_created( xmmsc_result_t* res, void* user_data )
{
    char* name = (char*)user_data;
    if( name && name[0] && name[0] != '_' )
        add_playlist_to_menu(name, TRUE);
    xmmsc_result_unref(res);

    if( ! cur_playlist )
    {
        /* load the default list */
        res = xmmsc_playlist_load(con, name);
        xmmsc_result_unref(res);
    }
}

static void on_playlists_listed( xmmsc_result_t* res, void* user_data )
{
    GSList* lists = NULL, *l;
    while( xmmsc_result_list_valid(res) )
    {
        char* str = NULL;
        guint r = xmmsc_result_get_string(res, &str);
        if( str && str[0] && str[0] != '_' )
            lists = g_slist_prepend(lists, str);
        xmmsc_result_list_next(res);
    }
    lists = g_slist_sort(lists, (GCompareFunc)g_utf8_collate);
    for(l = lists; l; l = l->next)
        add_playlist_to_menu((char*)l->data, FALSE);
    g_slist_free(lists);
    xmmsc_result_unref(res);

    /* If there is no playlist, create one */
    if( lists == NULL )
    {
        char* name = g_strdup(_("Default"));
        res = xmmsc_playlist_create(con, name);
        xmmsc_result_notifier_set_full(res, on_playlist_created, name, g_free);
        xmmsc_result_unref(res);
    }

    if( cur_playlist )
        update_play_list( playlist_view );
}

static void on_playlist_content_changed( xmmsc_result_t* res, void* user_data )
{
    guint id = 0;
    int type = 0, pos = -1;
    char* name = NULL;

    if( G_UNLIKELY( xmmsc_result_iserror( res ) ) )
        goto _out;

    if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_int( res, "type", &type ) ) )
        goto _out;

    if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_string( res, "name", &name ) ) )
        goto _out;

    if( ! name || !cur_playlist || strcmp(name, cur_playlist) )
        goto _out;

    /* g_debug("type=%d, name=%s", type, name); */

    if( ! list_store )
        goto _out;

    switch( type )
    {
        case XMMS_PLAYLIST_CHANGED_ADD:
        case XMMS_PLAYLIST_CHANGED_INSERT:
            if( G_UNLIKELY( ! xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
                pos = gtk_tree_model_iter_n_children( (GtkTreeModel*)list_store, NULL );
            if( G_LIKELY( xmmsc_result_get_dict_entry_uint( res, "id", &id ) ) )
            {
                GtkTreeIter it;
                gtk_list_store_insert_with_values( list_store, &it, pos,
                                                   COL_ID, id, -1 );
                g_debug("playlist_added: %d", id);
                queue_update_track( id, &it );
            }
            break;
        case XMMS_PLAYLIST_CHANGED_REMOVE:
            if( G_LIKELY( xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
            {
                GtkTreePath* path;
                GtkTreeIter it;
                path = gtk_tree_path_new_from_indices( pos, -1 );
                if( gtk_tree_model_get_iter( (GtkTreeModel*)list_store, &it, path ) )
                    gtk_list_store_remove( list_store, &it );
                gtk_tree_path_free( path );
            }
            break;
        case XMMS_PLAYLIST_CHANGED_CLEAR:
        {
            gtk_list_store_clear( list_store );
            break;
        }
        case XMMS_PLAYLIST_CHANGED_MOVE:
        {
            int newpos = 0;
            if( G_UNLIKELY( xmmsc_result_get_dict_entry_int( res, "position", &pos ) ) )
                break;
            if( G_UNLIKELY( xmmsc_result_get_dict_entry_int( res, "newposition", &newpos ) ) )
                break;
            break;
        }
        case XMMS_PLAYLIST_CHANGED_SORT:
        case XMMS_PLAYLIST_CHANGED_SHUFFLE:
        {
            update_play_list(playlist_view);
            break;
        }
        case XMMS_PLAYLIST_CHANGED_UPDATE:
            break;
    }
_out:
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playback_status_changed( xmmsc_result_t *res, void *user_data )
{
    GtkWidget* img;
    if ( !xmmsc_result_get_uint(res, &playback_status) )
    {
        playback_status = XMMS_PLAYBACK_STATUS_STOP;
        return;
    }

    switch( playback_status )
    {
        case XMMS_PLAYBACK_STATUS_PLAY:
            gtk_widget_set_tooltip_text( play_btn, _("Pause") );
            img = gtk_bin_get_child( (GtkBin*)play_btn );
            gtk_image_set_from_stock( (GtkImage*)img, GTK_STOCK_MEDIA_PAUSE,
                                      GTK_ICON_SIZE_BUTTON );
            break;
        case XMMS_PLAYBACK_STATUS_STOP:
            gtk_label_set_text( time_label, "--:--" );
            gtk_range_set_value( progress_bar, 0.0 );
        case XMMS_PLAYBACK_STATUS_PAUSE:
            gtk_widget_set_tooltip_text( play_btn, _("Play") );
            img = gtk_bin_get_child( (GtkBin*)play_btn );
            gtk_image_set_from_stock( (GtkImage*)img, GTK_STOCK_MEDIA_PLAY,
                                      GTK_ICON_SIZE_BUTTON );
            break;
    }

out:
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playback_playtime_changed( xmmsc_result_t* res, void* user_data )
{
    guint time;
    xmmsc_result_t* restart;
    char buf[32];
    if ( xmmsc_result_iserror(res)
         || ! xmmsc_result_get_uint(res, &time))
        return;

    restart = xmmsc_result_restart(res);
    xmmsc_result_unref(res);
    xmmsc_result_unref(restart);

    time /= 1000;
    if( time == play_time )
        return;
    play_time = time;

    gtk_label_set_text( (GtkLabel*)time_label,
                        timeval_to_str( time, buf, G_N_ELEMENTS(buf) ) );

    if( cur_track_duration > 0 )
    {
        g_signal_handlers_block_by_func(progress_bar, on_progress_bar_changed, user_data);
        gtk_range_set_value( (GtkRange*)progress_bar,
                              (((gdouble)100000 * time) / cur_track_duration) );
        g_signal_handlers_unblock_by_func(progress_bar, on_progress_bar_changed, user_data);
    }
}

static void on_playback_track_loaded( xmmsc_result_t* res, void* user_data )
{
    char* artist;
    char* title;
    char* tmp;
    if( !xmmsc_result_get_dict_entry_int( res, "duration",
                                          &cur_track_duration) )
        cur_track_duration = 0;

    if( !xmmsc_result_get_dict_entry_string( res, "artist", &artist ) )
        artist = NULL;

    if( !xmmsc_result_get_dict_entry_string( res, "title", &title ) )
        title = NULL;

    if( artist )
        tmp = g_strdup_printf( "LXMusic - %s - %s", artist, title );
    else if( title )
        tmp = g_strdup_printf( "LXMusic - %s", title );
    else
        tmp = g_strdup_printf( "LXMusic" );
    g_free(artist);
    g_free(title);
    gtk_window_set_title( main_win, tmp );
    /* gtk_statusbar_push(status_bar, 0, tmp); */

    g_free(tmp);
}

static void on_playback_cur_track_changed( xmmsc_result_t* res, void* user_data )
{
    if( xmmsc_result_get_uint(res, &cur_track_id) )
    {
        xmmsc_result_t *res2;
        char* name;
        res2 = xmmsc_medialib_get_info(con, cur_track_id);
        xmmsc_result_notifier_set(res2, on_playback_track_loaded, NULL);
        xmmsc_result_unref(res2);
    }
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void on_playlist_pos_changed( xmmsc_result_t* res, void* user_data )
{
    guint pos;
    GtkTreePath* path;
    GtkTreeSelection* sel;
    guint playlist_pos = 0;

    xmmsc_result_get_uint( res, &playlist_pos );
    /* g_debug("pos: %d", playlist_pos); */
/*
    FIXME: Currently we have no way to mark current played song in the playlist.

    path = gtk_tree_path_new_from_indices( playlist_pos, -1 );
    sel = gtk_tree_view_get_selection( (GtkTreeView*)list_view );
    gtk_tree_selection_select_path( sel, path );
    gtk_tree_path_free( path );
*/
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);
}

static void get_channel_volumes(const void *key, xmmsc_result_value_type_t type, const void *value, void *user_data)
{
    GSList** volumes = (GSList**)user_data;
    *volumes = g_slist_prepend(*volumes, value);
}

static void get_channel_volume_names(const void *key, xmmsc_result_value_type_t type, const void *value, void *user_data)
{
    GSList** volumes = (GSList**)user_data;
    *volumes = g_slist_prepend(*volumes, key);
}

void on_volume_btn_set_volume(xmmsc_result_t* res, void* user_data)
{
    GSList* volumes = NULL, *l;
    guint32 val = GPOINTER_TO_UINT(user_data);
    xmmsc_result_dict_foreach(res, get_channel_volume_names, &volumes);
    for( l = volumes; l; l = l->next )
    {
        xmmsc_result_t* res2;
        res2 = xmmsc_playback_volume_set(con, (char*)l->data, val);
        xmmsc_result_unref(res2);
    }
    g_slist_free(volumes);
    xmmsc_result_unref(res);
}

static void on_volume_btn_changed(GtkScaleButton* btn, gdouble val, gpointer user_data)
{
    xmmsc_result_t* res;
    res = xmmsc_playback_volume_get(con);
    xmmsc_result_notifier_set(res, on_volume_btn_set_volume, GUINT_TO_POINTER((guint32)val));
    xmmsc_result_unref(res);
}

static void on_playback_volume_changed( xmmsc_result_t* res, void* user_data )
{
    GSList* volumes = NULL, *l;
    guint vol = 0;
    xmmsc_result_dict_foreach(res, get_channel_volumes, &volumes);
    for( l = volumes; l; l = l->next )
    {
        if( vol < GPOINTER_TO_UINT(l->data) )
            vol = GPOINTER_TO_UINT(l->data);
    }
    g_slist_free(volumes);
    if( xmmsc_result_get_class(res) != XMMSC_RESULT_CLASS_BROADCAST )
        xmmsc_result_unref(res);

    g_signal_handlers_block_by_func( volume_btn, on_volume_btn_changed, NULL );
    gtk_scale_button_set_value( volume_btn, vol );
    g_signal_handlers_unblock_by_func( volume_btn, on_volume_btn_changed, NULL );
}

static void on_collection_changed( xmmsc_result_t* res, void* user_data )
{
    char *name, *ns;
    gint32 type;
    /* xmmsc_result_dict_foreach(res, dict_foreach, NULL); */
    xmmsc_result_get_dict_entry_string(res, "name", &name);
    xmmsc_result_get_dict_entry_string(res, "namespace", &ns);
    xmmsc_result_get_dict_entry_int(res, "type", &type);
    /* g_debug("name=%s, ns=%s, type=%d", name, ns, type); */

    /* currently we only care about playlists */
    if( ns && strcmp(ns, "Playlists") == 0 )
    {
        switch(type)
        {
        case XMMS_COLLECTION_CHANGED_ADD:
            add_playlist_to_menu( name, TRUE );
            break;
        case XMMS_COLLECTION_CHANGED_UPDATE:
            break;
        case XMMS_COLLECTION_CHANGED_RENAME:
            // rename_playlist( name, newname );
            break;
        case XMMS_COLLECTION_CHANGED_REMOVE:
            remove_playlist_from_menu( name );
            break;
        }
    }
}

static void on_media_lib_entry_changed(xmmsc_result_t* res, void* user_data)
{
    /* g_debug("mlib entry changed"); */
    uint32_t id = 0;
    if( xmmsc_result_get_uint(res, &id) )
    {
        GtkTreeModel* model = (GtkTreeModel*)list_store;
        GtkTreeIter it;
        if( !model )
            return;
        /* FIXME: This is damn inefficient, but I didn't have a
         * better way now.
         * Maybe it can be improved using custom tree model. :-( */
        if( gtk_tree_model_get_iter_first(model, &it) )
        {
            uint32_t _id;
            do{
                gtk_tree_model_get(model, &it, COL_ID, &_id, -1);
                if( _id == id )
                {
                    /* g_debug("found! update: %d", id); */
                    queue_update_track( id, &it );
                    break;
                }
            }while(gtk_tree_model_iter_next(model, &it));
        }
    }
}

static void config_changed_foreach(const void* _key, xmmsc_result_value_type_t type, const void* _val, void* user_data)
{
    const char* key = (const char*)_key;
    /* g_debug("key=%s, val=%s", key, _val); */
    if( strncmp( key, "playlist.", 9) == 0 )
    {
        const char* val = (const char*)_val;
        if( ! val )
            return;
        if( strcmp( key + 9, "repeat_one") == 0 )
        {
            if( val[0] == '1' )
                repeat_mode = REPEAT_CURRENT;
            else
            {
                if( repeat_mode == REPEAT_CURRENT )
                    repeat_mode = REPEAT_NONE;
            }
        }
        else if( strcmp( key + 9, "repeat_all") == 0 )
        {
            if( val[0] == '1' )
                repeat_mode = REPEAT_ALL;
            else
            {
                if( repeat_mode == REPEAT_ALL )
                    repeat_mode = REPEAT_NONE;
            }
        }
        g_signal_handlers_block_by_func(repeat_mode_cb, on_repeat_mode_changed, NULL );
        gtk_combo_box_set_active( repeat_mode_cb, repeat_mode );
        g_signal_handlers_unblock_by_func(repeat_mode_cb, on_repeat_mode_changed, NULL );
    }
}

static void on_configval_changed(xmmsc_result_t* res, void* user_data)
{
    xmmsc_result_dict_foreach(res, config_changed_foreach, NULL);
}

static void setup_xmms_callbacks()
{
    xmmsc_result_t* res;
    /* play status */
    res = xmmsc_playback_status(con);
    on_playback_status_changed( res, NULL );
    xmmsc_result_notifier_set(res, on_playback_status_changed, NULL);
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_status,
                       on_playback_status_changed, NULL );

    /* play time */
    /* this is a signal rather than broadcast, so restart is needed in the callback func. */
    XMMS_CALLBACK_SET( con, xmmsc_signal_playback_playtime,
                       on_playback_playtime_changed, NULL);

    /* playlist changed */
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playlist_changed,
                       on_playlist_content_changed, NULL );

    /* playlist loaded */
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playlist_loaded,
                       on_playlist_loaded, NULL );

    /* current track info */
    res = xmmsc_playback_current_id( con );
    xmmsc_result_notifier_set( res, on_playback_cur_track_changed, NULL );
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_current_id,
                       on_playback_cur_track_changed, NULL );

    /* current pos in playlist */
//    res = xmmsc_playlist_current_pos( con, "_active" );
//    xmmsc_result_notifier_set( res, on_playlist_pos_changed, NULL );
//    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playlist_current_pos,
                       on_playlist_pos_changed, NULL);

    /* volume */
    res = xmmsc_playback_volume_get(con);
    xmmsc_result_notifier_set(res, on_playback_volume_changed, NULL );
    xmmsc_result_unref(res);
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_playback_volume_changed,
                       on_playback_volume_changed, NULL );

    /* media lib */
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_medialib_entry_changed,
                       on_media_lib_entry_changed, NULL );

    XMMS_CALLBACK_SET( con, xmmsc_broadcast_collection_changed,
                       on_collection_changed, NULL );


    /* config values */
    XMMS_CALLBACK_SET( con, xmmsc_broadcast_configval_changed,
                       on_configval_changed, NULL );
}

void on_cfg_repeat_all_received(xmmsc_result_t* res, void* user_data)
{
    char* val;
    GtkComboBox* cb = (GtkComboBox*)user_data;
    if( xmmsc_result_get_string(res, &val) )
    {
        if( val && val[0] == '1' )
        {
            repeat_mode = REPEAT_ALL;
            gtk_combo_box_set_active( cb, repeat_mode );
        }
    }
    xmmsc_result_unref(res);
}

void on_cfg_repeat_one_received(xmmsc_result_t* res, void* user_data)
{
    GtkComboBox* cb = (GtkComboBox*)user_data;
    char* val;
    if( xmmsc_result_get_string(res, &val) )
    {
        if( val && val[0] == '1' )
        {
            repeat_mode = REPEAT_CURRENT;
            gtk_combo_box_set_active( cb, repeat_mode );
        }
    }
    xmmsc_result_unref(res);
}


static void setup_ui()
{
    GtkBuilder *builder;
    GtkUIManager* mgr;
    GtkWidget *hbox, *cb, *switch_pl_mi, *show_pl_mi;
    xmmsc_result_t* res;

    builder = gtk_builder_new();
    if( ! gtk_builder_add_from_file(builder, PACKAGE_DATA_DIR "/lxmusic/lxmusic.ui", NULL) )
        exit(1);

    main_win = (GtkWidget*)gtk_builder_get_object(builder, "main_win");
    play_btn = (GtkWidget*)gtk_builder_get_object(builder, "play_btn");
    time_label = (GtkWidget*)gtk_builder_get_object(builder, "time_label");
    progress_bar = (GtkWidget*)gtk_builder_get_object(builder, "progress_bar");
    notebook = (GtkWidget*)gtk_builder_get_object(builder, "notebook");
    status_bar = (GtkWidget*)gtk_builder_get_object(builder, "status_bar");

    inner_vbox = (GtkWidget*)gtk_builder_get_object(builder, "inner_vbox");
    playlist_view = (GtkWidget*)gtk_builder_get_object(builder, "playlist_view");

    repeat_mode_cb = (GtkWidget*)gtk_builder_get_object(builder, "repeat_mode");

    mgr = (GtkUIManager*)gtk_builder_get_object(builder, "uimanager1");
    switch_pl_mi = gtk_ui_manager_get_widget( mgr, "/menubar/playlist_mi/switch_to_pl" );
    switch_pl_menu = gtk_menu_new();
    gtk_menu_item_set_submenu(switch_pl_mi, switch_pl_menu);

    add_to_pl_menu = gtk_menu_item_get_submenu(gtk_ui_manager_get_widget( mgr, "/menubar/playlist_mi/add_to_pl" ));
    rm_from_pl_menu = gtk_menu_item_get_submenu(gtk_ui_manager_get_widget( mgr, "/menubar/playlist_mi/remove_from_pl" ));

    show_pl_mi = gtk_ui_manager_get_widget( mgr, "/menubar/view_mi/show_pl" );

    cb = (GtkWidget*)gtk_builder_get_object(builder, "repeat_mode");
    gtk_combo_box_set_active(cb, REPEAT_NONE);
//    gtk_combo_box_set_active(cb, repeat_mode);
    res = xmmsc_configval_get( con, "playlist.repeat_all" );
    xmmsc_result_notifier_set( res, on_cfg_repeat_all_received, cb );
    xmmsc_result_unref(res);
    res = xmmsc_configval_get( con, "playlist.repeat_one" );
    xmmsc_result_notifier_set( res, on_cfg_repeat_one_received, cb );
    xmmsc_result_unref(res);

    cb = (GtkWidget*)gtk_builder_get_object(builder, "filter_field");
    gtk_combo_box_set_active(cb, filter_field);

    /* add volume button */
    hbox = (GtkWidget*)gtk_builder_get_object(builder, "top_hbox");
    volume_btn = gtk_volume_button_new();
    gtk_scale_button_get_adjustment(volume_btn)->upper = 100;
    gtk_widget_show(volume_btn);
    gtk_box_pack_start(hbox, volume_btn, FALSE, TRUE, 0);
    g_signal_connect(volume_btn, "value-changed", G_CALLBACK(on_volume_btn_changed), NULL);

    /* init the playlist widget */
    init_playlist(playlist_view);

    /* signal handlers */
    gtk_builder_connect_signals(builder, NULL);

    gtk_window_set_default_size(main_win, win_width, win_height);
    /* this can trigger signal handler and show or hide the playlist. */
    gtk_check_menu_item_set_active(show_pl_mi, show_playlist);

    g_object_unref(builder);
    gtk_widget_show_all(notebook);
    gtk_widget_show (main_win);

    /* tray icon */
    if( show_tray_icon )
        create_tray_icon();
}

void on_new_playlist(GtkAction* act, gpointer user_data)
{
    GtkWidget *dlg = gtk_dialog_new_with_buttons(
            _("Create new playlist"), (GtkWindow*)main_win, GTK_DIALOG_MODAL,
            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
            GTK_STOCK_OK, GTK_RESPONSE_OK, NULL );
    GtkWidget *entry = gtk_entry_new();
    gtk_box_pack_start( (GtkBox*)((GtkDialog*)dlg)->vbox, entry, FALSE, FALSE, 4 );
    gtk_dialog_set_default_response( (GtkDialog*)dlg, GTK_RESPONSE_OK );
    gtk_entry_set_activates_default( (GtkEntry*)entry, TRUE );
    gtk_widget_show_all( dlg );
    if( gtk_dialog_run( (GtkDialog*)dlg ) == GTK_RESPONSE_OK )
    {
        xmmsc_result_t *res;
        const char* name = gtk_entry_get_text( (GtkEntry*)entry );
        res = xmmsc_playlist_create( con, name );
        xmmsc_result_unref( res );

        /* load the newly created list */
        xmmsc_playlist_load(con, name);
        xmmsc_result_unref( res );
    }
    gtk_widget_destroy( dlg );
}

void on_del_playlist(GtkAction* act, gpointer user_data)
{
    GSList *prev=NULL, *l;
    char* switch_to = NULL;

    /* NOTE: we should at least have one playlist */
    if( !switch_pl_menu_group || !switch_pl_menu_group )
        return;
    if( ! cur_playlist )
        return;

    /* switching to another playlist before removing the current one. */
    for( l = all_playlists; l; l = l->next )
    {
        char* name = (char*)l->data;
        if( 0 == strcmp( name, cur_playlist ) )
        {
            if( l->next )
                switch_to = (char*)l->next->data;
            else if(prev)
                switch_to = (char*)prev->data;
            break;
        }
        prev= l;
    }
    if( switch_to )
    {
        xmmsc_result_t* res;
        res = xmmsc_playlist_load(con, switch_to);
        xmmsc_result_unref(res);

        res = xmmsc_playlist_remove(con, cur_playlist);
        xmmsc_result_unref(res);
    }
}

void on_show_playlist(GtkAction* act, gpointer user_data)
{
    show_playlist = gtk_toggle_action_get_active(act);
    if(GTK_WIDGET_VISIBLE(inner_vbox))
    {
        if( ! show_playlist )
        {
            /* save current size to restore it later. */
            gtk_window_get_size(main_win, &win_width, &win_height );
            gtk_widget_hide(inner_vbox);
            /* Dirty trick used to shrink the window to its minimal size */
            gtk_window_resize(main_win, 1, 1);
        }
    }
    else
    {
        if( show_playlist )
        {
            gtk_window_resize(main_win, win_width, win_height );
            gtk_widget_show(inner_vbox);
        }
    }
}

void on_playlist_cut(GtkAction* act, gpointer user_data)
{
    g_debug("Not yet implemented");
}

void on_playlist_copy(GtkAction* act, gpointer user_data)
{
    g_debug("Not yet implemented");
}

void on_playlist_paste(GtkAction* act, gpointer user_data)
{

}


int main (int argc, char *argv[])
{
    xmmsc_result_t* res;

#ifdef ENABLE_NLS
    bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
    textdomain (GETTEXT_PACKAGE);
#endif

    if( !(con = xmmsc_init ("lxmusic")) )
        return EXIT_FAILURE;

    /* try to connect to xmms2d, and launch the daemon if needed. */
    if( !xmmsc_connect(con, getenv("XMMS_PATH")) )
    {
        if( ! g_spawn_command_line_sync( "xmms2-launcher", NULL, NULL, NULL, NULL )
            || !xmmsc_connect(con, getenv ("XMMS_PATH")) )
        {
            fprintf(stderr, "Connection failed: %s\n",
                     xmmsc_get_last_error (con));
            return EXIT_FAILURE;
        }
    }

    gtk_init(&argc, &argv);
    xmmsc_mainloop_gmain_init(con);

    load_config();

    /* build the GUI */
    setup_ui();

    /* some dirty hacks to show the window earlier :-D */
    while( gtk_events_pending() )
        gtk_main_iteration();
    gdk_display_sync(gtk_widget_get_display(main_win));

    pending_update_tracks = g_queue_new();

    /* display currently active playlist */
    res = xmmsc_playlist_current_active(con);
    xmmsc_result_notifier_set(res, on_playlist_get_active, NULL);
    xmmsc_result_unref(res);

    /* load all existing playlists and add them to the menu */
    res = xmmsc_playlist_list( con );
    xmmsc_result_notifier_set(res, on_playlists_listed, NULL);
    xmmsc_result_unref(res);

    /* register callbacks */
    setup_xmms_callbacks();

    gtk_main ();

    g_queue_free(pending_update_tracks);
    save_config();

    return 0;
}

